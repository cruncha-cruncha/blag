<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" href="data:,">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <title>Bug Blog</title>
    <style>
        .text-right {
            text-align: right;
        }
    </style>
    <script>
        // see PublicInfoFile in info.rs for schema
        const data = {"pageNum":0,"searchTerm":"","articles":[{"originalTitle":"Extra-Fuzzy Search with Bloom-Filtered Trigrams","safeTitle":"extra-fuzzy_search_with_bloom-filtered_trigrams","createdAt":1767646164,"tags":["hashing","linear","n-grams","strings","text","hacky","sloppy","bug blog"]}],"results":[]}
    </script>
    <script>
        const pageSize = 10;
        const urlSearchParam = "search";
        const urlPageParam = "page";
        const searchLimit = 256; // max search term length

        // 1. lowercase
        // 2. replace all non-alphanumeric (excluding #) with space
        // 3. remove all spaces
        // example: "Hello, World! #This\nis a test." -> "helloworld#thisisatest"
        const squashText = (text) => {
            return text.toLowerCase().replace(/[^a-z0-9#]/g, " ").replace(/\s+/g, "");
        }

        // takes a string, returns all unique 3-letter chunks
        // does not squash or otherwise preprocess the text
        const buildTrigrams = (text) => {
            const trigrams = new Set();
            for (let i = 0; i < text.length - 2; i++) {
                const trigram = text.substring(i, i + 3);
                trigrams.add(trigram);
            }
            return trigrams;
        }

        // 'djb2' hash function, specifically for trigrams
        // idk if this is right or not but it seems to work
        const djb2tri = (tri) => {
            let h = 5381;
            for (let i = 0; i < 33; i++) {
                h = ((h << 5) + h) ^ tri.charCodeAt(i%3);
            }
            return Math.abs(h);
        }

        // creates a bloom filter from any set of strings (trigrams, in practice)
        // the bloom filter is a Uint8Array of length 256 (2048 bits)
        // uses 2 hash functions (djb2 and djb2 shifted) to set bits
        // can store 500 elements (strings) with a false positive rate < 5%
        const blossom = (trigrams) => {
            const result = new Uint8Array(256); // 2048 bits = 256 bytes
            trigrams.forEach(trigram => {
                const hash = djb2tri(trigram);
                const bitPos1 = hash % 2048;
                const bitPos2 = (hash >> 11) % 2048;

                result[Math.floor(bitPos1 / 8)] |= (1 << (bitPos1 % 8));
                result[Math.floor(bitPos2 / 8)] |= (1 << (bitPos2 % 8));
            });
            return result;
        }

        // build a bloom filter for each article, then store it in article.bloom
        const buildBlooms = () => {
            data.articles.forEach(article => {
                const allTrigrams = new Set();

                const squashedTitle = squashText(article.originalTitle);
                const titleTrigrams = buildTrigrams(squashedTitle);
                titleTrigrams.forEach(tri => allTrigrams.add(tri));

                for (tag of article.tags) {
                    const squashedTag = squashText(tag);
                    const tagTrigrams = buildTrigrams(squashedTag);
                    tagTrigrams.forEach(tri => allTrigrams.add(tri));
                }

                article.bloom = blossom(allTrigrams);
            });
        }

        // count the number of matching bits between two bloom filters
        // not strictly kosher bloom filter usage, but works for our purposes
        const compareBlooms = (needle, haystack) => {
            let score = 0;
            for (let i = 0; i < needle.length; i++) {
                const nByte = needle[i];
                const hByte = haystack[i];
                const commonBits = nByte & hByte;
                // count set bits in commonBits
                for (let b = 0; b < 8; b++) {
                    if (commonBits & (1 << b)) {
                        score++;
                    }
                }
            }
            return score;
        }

        // update the ui to display only result articles
        // also update page number
        const updateHtml = () => {
            const articlesDiv = document.getElementById("articles");
            articlesDiv.innerHTML = "";
            data.results.forEach(article => {
                const dateSpan = document.createElement("span");
                dateSpan.className = "text-right";
                const date = new Date(article.createdAt * 1000);
                dateSpan.textContent = date.toISOString().slice(0, 10);
                articlesDiv.appendChild(dateSpan);

                const titleLink = document.createElement("a");
                titleLink.href = `/${article.safeTitle}.html`;
                titleLink.textContent = article.originalTitle;
                articlesDiv.appendChild(titleLink);
            });

            const pageNumSpan = document.getElementById("page-num");
            pageNumSpan.textContent = (data.pageNum + 1).toString();
        }

        // check pageNum and searchTerm, then filter/sort/slice articleInfo into results
        const updateResults = () => {
            if (data.searchTerm.length < 3) {
                data.results = data.articles.slice(data.pageNum * pageSize, (data.pageNum + 1) * pageSize);
                updateHtml();
                return;
            }

            const squashedSearch = squashText(data.searchTerm);
            const searchTrigrams = buildTrigrams(squashedSearch);
            const searchBloom = blossom(searchTrigrams);

            let articleScores = [];
            for (let i = 0; i < data.articles.length; i++) {
                const article = data.articles[i];
                const score = compareBlooms(searchBloom, article.bloom);
                if (score > 0) {
                    articleScores.push({ index: i, score: score });
                }
            }

            // assume that data.articles is pre-sorted by createdAt desc
            // the above for loop scores each article in order, and the below Array.sort is stable
            // so articles with the same score will remain in createdAt desc order

            articleScores.sort((a, b) => b.score - a.score);
            articleScores = articleScores.slice(data.pageNum * pageSize, (data.pageNum + 1) * pageSize);
            data.results = articleScores.map(as => data.articles[as.index]);
            updateHtml();
        }

        // handle input event on search bar
        const handleSearchInput = (event) => {
            let search = event.target.value;
            if (search.length > searchLimit) {
                search = search.slice(0, searchLimit);
            }
            data.searchTerm = search;
            data.pageNum = 0;
            updateUrlParam(urlSearchParam, data.searchTerm);
            updateUrlParam(urlPageParam, data.pageNum);
            updateResults();
        };

        // update a single URL parameter without reloading the page
        const updateUrlParam = (key, val) => {
            const params = new URLSearchParams(window.location.search);
            params.set(key, val);
            window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
        };

        // handle click on 'prev' button
        const handlePrevClick = () => {
            if (data.pageNum <= 0) return;
            data.pageNum = data.pageNum - 1;
            updateUrlParam(urlPageParam, data.pageNum);
            updateResults();
        };

        // handle click on 'next' button
        const handleNextClick = () => {
            data.pageNum = data.pageNum + 1;
            updateUrlParam(urlPageParam, data.pageNum);
            updateResults();
        };

        // read pageNum and searchTerm from URL params on load
        window.onload = () => {
            const params = new URLSearchParams(window.location.search);

            const pageParam = params.get("page");
            if (pageParam) {
                const pageNum = parseInt(pageParam);
                if (!isNaN(pageNum) && pageNum >= 0) {
                    data.pageNum = pageNum;
                }
            }
            
            let searchParam = params.get("search");
            if (searchParam) {
                if (searchParam.length > searchLimit) {
                    searchParam = searchParam.slice(0, searchLimit);
                }
                data.searchTerm = searchParam;
                const searchBar = document.getElementById("search-bar");
                searchBar.value = data.searchTerm;
            }

            // display results based on initial params
            updateResults();
        };

        // build bloom filters for all articles
        buildBlooms();
    </script>
</head>

<body>
    <div style="max-width:800px;margin-left:auto;margin-right:auto;display:grid;grid-template-columns:max-content auto;column-gap:0.6rem;">
        <!-- cheeky lil spacer to align dates -->
        <span style="visibility:hidden;">2020-01-01-</span>
        <div style="margin-bottom:1rem;">
            <h1 style="margin:0;">Bug Blog</h1>
            <input id="search-bar" type="text" name="search" placeholder="search" oninput="handleSearchInput(event)">
        </div>
        <div id="articles" style="display:grid;grid-template-columns:subgrid;grid-column:1/-1;row-gap:0.4rem;">
        </div>
        <div style="grid-column:2;margin-top:0.8rem;display:flex;gap:1rem;align-items:center;">
            <button id="prev" onclick="handlePrevClick()">prev</button>
            <span id="page-num">1</span>
            <button id="next" onclick="handleNextClick()">next</button>
        </div>
        <a href="https://github.com/cruncha-cruncha/blag" style="grid-column:2;margin-top:0.6rem;">source</a>
    </div>
</body>

</html>